{"ast":null,"code":"import { Buffer } from 'buffer';\nimport { verify } from '@stablelib/ed25519';\nimport { hash } from '@stablelib/blake2b';\nimport blake from 'blakejs';\nimport bs58check from 'bs58check';\nimport elliptic from 'elliptic';\nimport toBuffer from 'typedarray-to-buffer';\nvar Prefix;\n\n(function (Prefix) {\n  Prefix[\"TZ1\"] = \"tz1\";\n  Prefix[\"TZ2\"] = \"tz2\";\n  Prefix[\"TZ3\"] = \"tz3\";\n  Prefix[\"TZ4\"] = \"tz4\";\n  Prefix[\"KT\"] = \"KT\";\n  Prefix[\"KT1\"] = \"KT1\";\n  Prefix[\"EDSK2\"] = \"edsk2\";\n  Prefix[\"SPSK\"] = \"spsk\";\n  Prefix[\"P2SK\"] = \"p2sk\";\n  Prefix[\"EDPK\"] = \"edpk\";\n  Prefix[\"SPPK\"] = \"sppk\";\n  Prefix[\"P2PK\"] = \"p2pk\";\n  Prefix[\"BLPK\"] = \"BLpk\";\n  Prefix[\"EDESK\"] = \"edesk\";\n  Prefix[\"SPESK\"] = \"spesk\";\n  Prefix[\"P2ESK\"] = \"p2esk\";\n  Prefix[\"EDSK\"] = \"edsk\";\n  Prefix[\"EDSIG\"] = \"edsig\";\n  Prefix[\"SPSIG\"] = \"spsig\";\n  Prefix[\"P2SIG\"] = \"p2sig\";\n  Prefix[\"SIG\"] = \"sig\";\n  Prefix[\"NET\"] = \"Net\";\n  Prefix[\"NCE\"] = \"nce\";\n  Prefix[\"B\"] = \"B\";\n  Prefix[\"O\"] = \"o\";\n  Prefix[\"LO\"] = \"Lo\";\n  Prefix[\"LLO\"] = \"LLo\";\n  Prefix[\"P\"] = \"P\";\n  Prefix[\"CO\"] = \"Co\";\n  Prefix[\"ID\"] = \"id\";\n  Prefix[\"EXPR\"] = \"expr\";\n  Prefix[\"TZ\"] = \"TZ\";\n  Prefix[\"VH\"] = \"vh\"; //rollups\n\n  Prefix[\"TXR1\"] = \"txr1\";\n  Prefix[\"TXI\"] = \"txi\";\n  Prefix[\"TXM\"] = \"txm\";\n  Prefix[\"TXC\"] = \"txc\";\n  Prefix[\"TXMR\"] = \"txmr\";\n  Prefix[\"TXRL\"] = \"txM\";\n  Prefix[\"TXW\"] = \"txw\";\n})(Prefix || (Prefix = {}));\n\nconst prefix = {\n  [Prefix.TZ1]: new Uint8Array([6, 161, 159]),\n  [Prefix.TZ2]: new Uint8Array([6, 161, 161]),\n  [Prefix.TZ3]: new Uint8Array([6, 161, 164]),\n  [Prefix.TZ4]: new Uint8Array([6, 161, 166]),\n  [Prefix.KT]: new Uint8Array([2, 90, 121]),\n  [Prefix.KT1]: new Uint8Array([2, 90, 121]),\n  [Prefix.EDSK]: new Uint8Array([43, 246, 78, 7]),\n  [Prefix.EDSK2]: new Uint8Array([13, 15, 58, 7]),\n  [Prefix.SPSK]: new Uint8Array([17, 162, 224, 201]),\n  [Prefix.P2SK]: new Uint8Array([16, 81, 238, 189]),\n  [Prefix.EDPK]: new Uint8Array([13, 15, 37, 217]),\n  [Prefix.SPPK]: new Uint8Array([3, 254, 226, 86]),\n  [Prefix.P2PK]: new Uint8Array([3, 178, 139, 127]),\n  [Prefix.BLPK]: new Uint8Array([6, 149, 135, 204]),\n  [Prefix.EDESK]: new Uint8Array([7, 90, 60, 179, 41]),\n  [Prefix.SPESK]: new Uint8Array([0x09, 0xed, 0xf1, 0xae, 0x96]),\n  [Prefix.P2ESK]: new Uint8Array([0x09, 0x30, 0x39, 0x73, 0xab]),\n  [Prefix.EDSIG]: new Uint8Array([9, 245, 205, 134, 18]),\n  [Prefix.SPSIG]: new Uint8Array([13, 115, 101, 19, 63]),\n  [Prefix.P2SIG]: new Uint8Array([54, 240, 44, 52]),\n  [Prefix.SIG]: new Uint8Array([4, 130, 43]),\n  [Prefix.NET]: new Uint8Array([87, 82, 0]),\n  [Prefix.NCE]: new Uint8Array([69, 220, 169]),\n  [Prefix.B]: new Uint8Array([1, 52]),\n  [Prefix.O]: new Uint8Array([5, 116]),\n  [Prefix.LO]: new Uint8Array([133, 233]),\n  [Prefix.LLO]: new Uint8Array([29, 159, 109]),\n  [Prefix.P]: new Uint8Array([2, 170]),\n  [Prefix.CO]: new Uint8Array([79, 179]),\n  [Prefix.ID]: new Uint8Array([153, 103]),\n  [Prefix.EXPR]: new Uint8Array([13, 44, 64, 27]),\n  // Legacy prefix\n  [Prefix.TZ]: new Uint8Array([2, 90, 121]),\n  [Prefix.VH]: new Uint8Array([1, 106, 242]),\n  [Prefix.TXR1]: new Uint8Array([1, 128, 120, 31]),\n  [Prefix.TXI]: new Uint8Array([79, 148, 196]),\n  [Prefix.TXM]: new Uint8Array([79, 149, 30]),\n  [Prefix.TXC]: new Uint8Array([79, 148, 17]),\n  [Prefix.TXMR]: new Uint8Array([18, 7, 206, 87]),\n  [Prefix.TXRL]: new Uint8Array([79, 146, 82]),\n  [Prefix.TXW]: new Uint8Array([79, 150, 72])\n};\nconst prefixLength = {\n  [Prefix.TZ1]: 20,\n  [Prefix.TZ2]: 20,\n  [Prefix.TZ3]: 20,\n  [Prefix.TZ4]: 20,\n  [Prefix.KT]: 20,\n  [Prefix.KT1]: 20,\n  [Prefix.EDPK]: 32,\n  [Prefix.SPPK]: 33,\n  [Prefix.P2PK]: 33,\n  //working with value in comment for base58.ml line 445 but not consistent with the three above\n  [Prefix.BLPK]: 48,\n  [Prefix.EDSIG]: 64,\n  [Prefix.SPSIG]: 64,\n  [Prefix.P2SIG]: 64,\n  [Prefix.SIG]: 64,\n  [Prefix.NET]: 4,\n  [Prefix.B]: 32,\n  [Prefix.P]: 32,\n  [Prefix.O]: 32,\n  [Prefix.VH]: 32,\n  [Prefix.TXR1]: 20,\n  [Prefix.TXI]: 32,\n  [Prefix.TXM]: 32,\n  [Prefix.TXC]: 32,\n  [Prefix.TXMR]: 32,\n  [Prefix.TXRL]: 32,\n  [Prefix.TXW]: 32\n};\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid key being passed or used\r\n */\n\nclass InvalidKeyError extends Error {\n  constructor(key, errorDetail) {\n    super(`The key ${key} is invalid. ${errorDetail}`);\n    this.key = key;\n    this.errorDetail = errorDetail;\n    this.name = 'InvalidKeyError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an Invalid Public Key being passed or used\r\n */\n\n\nclass InvalidPublicKeyError extends Error {\n  constructor(publicKey, errorDetail) {\n    super(`The public key '${publicKey}' is invalid. ${errorDetail}`);\n    this.publicKey = publicKey;\n    this.name = 'InvalidPublicKeyError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid signature being passed or used\r\n */\n\n\nclass InvalidSignatureError extends Error {\n  constructor(signature, errorDetail) {\n    super(`The signature '${signature}' is invalid (${errorDetail})`);\n    this.signature = signature;\n    this.name = 'InvalidSignatureError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid message being passed or used\r\n */\n\n\nclass InvalidMessageError extends Error {\n  constructor(msg, errorDetail) {\n    super(`The message '${msg}' is invalid. ${errorDetail}`);\n    this.msg = msg;\n    this.errorDetail = errorDetail;\n    this.name = 'InvalidMessageError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid contract address being passed or used\r\n */\n\n\nclass InvalidContractAddressError extends Error {\n  constructor(contractAddress) {\n    super(`The contract address '${contractAddress}' is invalid`);\n    this.contractAddress = contractAddress;\n    this.name = 'InvalidContractAddressError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid address being passed or used (both contract and implicit)\r\n */\n\n\nclass InvalidAddressError extends Error {\n  constructor(address) {\n    super(`The address '${address}' is invalid`);\n    this.address = address;\n    this.name = 'InvalidAddressError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid chain id being passed or used\r\n */\n\n\nclass InvalidChainIdError extends Error {\n  constructor(chainId) {\n    super(`The chain id '${chainId}' is invalid`);\n    this.chainId = chainId;\n    this.name = 'InvalidChainIdError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid key hash being passed or used\r\n */\n\n\nclass InvalidKeyHashError extends Error {\n  constructor(keyHash) {\n    super(`The public key hash '${keyHash}' is invalid`);\n    this.keyHash = keyHash;\n    this.name = 'InvalidKeyHashError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid block hash being passed or used\r\n */\n\n\nclass InvalidBlockHashError extends Error {\n  constructor(blockHash) {\n    super(`The block hash '${blockHash}' is invalid`);\n    this.blockHash = blockHash;\n    this.name = 'InvalidBlockHashError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates invalid protocol hash being passed or used\r\n */\n\n\nclass InvalidProtocolHashError extends Error {\n  constructor(protocolHash) {\n    super(`The protocol hash '${protocolHash}' is invalid`);\n    this.protocolHash = protocolHash;\n    this.name = 'InvalidProtocolHashError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid operation hash being passed or used\r\n */\n\n\nclass InvalidOperationHashError extends Error {\n  constructor(operationHash) {\n    super(`The operation hash '${operationHash}' is invalid`);\n    this.operationHash = operationHash;\n    this.name = 'InvalidOperationHashError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid operation kind being passed or used\r\n */\n\n\nclass InvalidOperationKindError extends Error {\n  constructor(operationKind) {\n    super(`The operation kind '${operationKind}' is unsupported`);\n    this.operationKind = operationKind;\n    this.name = 'InvalidOperationKindError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description General error that indicates something is no longer supported and/or deprecated\r\n */\n\n\nclass DeprecationError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'DeprecationError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description General error that indicates an action is prohibited or not allowed\r\n */\n\n\nclass ProhibitedActionError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'ProhibitedActionError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description General error that indicates a failure when trying to convert data from one type to another\r\n */\n\n\nclass ValueConversionError extends Error {\n  constructor(value, desiredType) {\n    super(`Unable to convert ${value} to a ${desiredType}`);\n    this.value = value;\n    this.desiredType = desiredType;\n    this.name = 'ValueConversionError';\n  }\n\n}\n/**\r\n * @description Verify signature of a payload\r\n *\r\n * @param messageBytes The forged message including the magic byte (11 for block,\r\n *        12 for preendorsement, 13 for endorsement, 3 for generic, 5 for the PACK format of michelson)\r\n * @param publicKey The public key to verify the signature against\r\n * @param signature The signature to verify\r\n * @returns A boolean indicating if the signature matches\r\n *\r\n * @example\r\n * ```\r\n * const message = '03d0c10e3ed11d7c6e3357f6ef335bab9e8f2bd54d0ce20c482e241191a6e4b8ce6c01be917311d9ac46959750e405d57e268e2ed9e174a80794fbd504e12a4a000141eb3781afed2f69679ff2bbe1c5375950b0e40d00ff000000005e05050505050507070100000024747a32526773486e74516b72794670707352466261313652546656503539684b72654a4d07070100000024747a315a6672455263414c42776d4171776f6e525859565142445439426a4e6a42484a750001';\r\n * const pk = 'sppk7c7hkPj47yjYFEHX85q46sFJGw6RBrqoVSHwAJAT4e14KJwzoey';\r\n * const sig = 'spsig1cdLkp1RLgUHAp13aRFkZ6MQDPp7xCnjAExGL3MBSdMDmT6JgQSX8cufyDgJRM3sinFtiCzLbsyP6d365EHoNevxhT47nx'\r\n *\r\n * const response = verifySignature(message, pk, sig);\r\n * ```\r\n *\r\n */\n\n\nfunction verifySignature(messageBytes, publicKey, signature) {\n  const pkPrefix = validatePkAndExtractPrefix(publicKey);\n  const sigPrefix = validateSigAndExtractPrefix(signature);\n  const decodedPublicKey = b58cdecode(publicKey, prefix[pkPrefix]);\n  const decodedSig = b58cdecode(signature, prefix[sigPrefix]);\n  const bytesHash = hash(hex2buf(validateMessageNotEmpty(messageBytes)), 32);\n\n  if (pkPrefix === Prefix.EDPK) {\n    return verifyEdSignature(decodedSig, bytesHash, decodedPublicKey);\n  } else if (pkPrefix === Prefix.SPPK) {\n    return verifySpSignature(decodedSig, bytesHash, decodedPublicKey);\n  } else if (pkPrefix === Prefix.P2PK) {\n    return verifyP2Signature(decodedSig, bytesHash, decodedPublicKey);\n  } else {\n    return false;\n  }\n}\n\nfunction validateMessageNotEmpty(message) {\n  if (message === '') {\n    throw new InvalidMessageError(message, 'The message provided for verifying signature cannot be empty.');\n  }\n\n  return message;\n}\n\nfunction validatePkAndExtractPrefix(publicKey) {\n  if (publicKey === '') {\n    throw new InvalidPublicKeyError(publicKey, 'Public key cannot be empty');\n  }\n\n  const pkPrefix = publicKey.substring(0, 4);\n  const validation = validatePublicKey(publicKey);\n\n  if (validation !== ValidationResult.VALID) {\n    if (validation === ValidationResult.INVALID_CHECKSUM) {\n      throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid checksum');\n    } else if (validation === ValidationResult.INVALID_LENGTH) {\n      throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid length');\n    } else if (validation === ValidationResult.NO_PREFIX_MATCHED) {\n      throw new InvalidPublicKeyError(publicKey, `The public key provided has an unsupported prefix: ${pkPrefix}`);\n    }\n  }\n\n  return pkPrefix;\n}\n\nfunction validateSigAndExtractPrefix(signature) {\n  const signaturePrefix = signature.startsWith('sig') ? signature.substr(0, 3) : signature.substr(0, 5);\n  const validation = validateSignature(signature);\n\n  if (validation !== ValidationResult.VALID) {\n    if (validation === ValidationResult.INVALID_CHECKSUM) {\n      throw new InvalidSignatureError(signature, `invalid checksum`);\n    } else if (validation === ValidationResult.INVALID_LENGTH) {\n      throw new InvalidSignatureError(signature, 'invalid length');\n    } else if (validation === ValidationResult.NO_PREFIX_MATCHED) {\n      throw new InvalidSignatureError(signaturePrefix, 'unsupported prefix');\n    }\n  }\n\n  return signaturePrefix;\n}\n\nfunction verifyEdSignature(decodedSig, bytesHash, decodedPublicKey) {\n  try {\n    return verify(decodedPublicKey, bytesHash, decodedSig);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction verifySpSignature(decodedSig, bytesHash, decodedPublicKey) {\n  const key = new elliptic.ec('secp256k1').keyFromPublic(decodedPublicKey);\n  return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\n\nfunction verifyP2Signature(decodedSig, bytesHash, decodedPublicKey) {\n  const key = new elliptic.ec('p256').keyFromPublic(decodedPublicKey);\n  return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\n\nfunction verifySpOrP2Sig(decodedSig, bytesHash, key) {\n  const hexSig = buf2hex(toBuffer(decodedSig));\n  const match = hexSig.match(/([a-f\\d]{64})/gi);\n\n  if (match) {\n    try {\n      const [r, s] = match;\n      return key.verify(bytesHash, {\n        r,\n        s\n      });\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nvar ValidationResult;\n\n(function (ValidationResult) {\n  ValidationResult[ValidationResult[\"NO_PREFIX_MATCHED\"] = 0] = \"NO_PREFIX_MATCHED\";\n  ValidationResult[ValidationResult[\"INVALID_CHECKSUM\"] = 1] = \"INVALID_CHECKSUM\";\n  ValidationResult[ValidationResult[\"INVALID_LENGTH\"] = 2] = \"INVALID_LENGTH\";\n  ValidationResult[ValidationResult[\"VALID\"] = 3] = \"VALID\";\n})(ValidationResult || (ValidationResult = {}));\n\nfunction isValidPrefix(value) {\n  if (typeof value !== 'string') {\n    return false;\n  }\n\n  return value in prefix;\n}\n/**\r\n * @description This function is called by the validation functions ([[validateAddress]], [[validateChain]], [[validateContractAddress]], [[validateKeyHash]], [[validateSignature]], [[validatePublicKey]]).\r\n * Verify if the value has the right prefix or return `NO_PREFIX_MATCHED`,\r\n * decode the value using base58 and return `INVALID_CHECKSUM` if it fails,\r\n * check if the length of the value matches the prefix type or return `INVALID_LENGTH`.\r\n * If all checks pass, return `VALID`.\r\n *\r\n * @param value Value to validate\r\n * @param prefixes prefix the value should have\r\n */\n\n\nfunction validatePrefixedValue(value, prefixes) {\n  const match = new RegExp(`^(${prefixes.join('|')})`).exec(value);\n\n  if (!match || match.length === 0) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  }\n\n  const prefixKey = match[0];\n\n  if (!isValidPrefix(prefixKey)) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  } // Remove annotation from contract address before doing the validation\n\n\n  const contractAddress = /^(KT1\\w{33})(%(.*))?/.exec(value);\n\n  if (contractAddress) {\n    value = contractAddress[1];\n  } // decodeUnsafe return undefined if decoding fail\n\n\n  let decoded = bs58check.decodeUnsafe(value);\n\n  if (!decoded) {\n    return ValidationResult.INVALID_CHECKSUM;\n  }\n\n  decoded = decoded.slice(prefix[prefixKey].length);\n\n  if (decoded.length !== prefixLength[prefixKey]) {\n    return ValidationResult.INVALID_LENGTH;\n  }\n\n  return ValidationResult.VALID;\n}\n\nconst implicitPrefix = [Prefix.TZ1, Prefix.TZ2, Prefix.TZ3, Prefix.TZ4];\nconst contractPrefix = [Prefix.KT1, Prefix.TXR1];\nconst signaturePrefix = [Prefix.EDSIG, Prefix.P2SIG, Prefix.SPSIG, Prefix.SIG];\nconst pkPrefix = [Prefix.EDPK, Prefix.SPPK, Prefix.P2PK, Prefix.BLPK];\nconst operationPrefix = [Prefix.O];\nconst protocolPrefix = [Prefix.P];\nconst blockPrefix = [Prefix.B];\n/**\r\n * @description Used to check if an address or a contract address is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateAddress } from '@taquito/utils';\r\n * const pkh = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\r\n * const validation = validateAddress(pkh)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\nfunction validateAddress(value) {\n  return validatePrefixedValue(value, [...implicitPrefix, ...contractPrefix]);\n}\n/**\r\n * @description Used to check if a chain id is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateChain } from '@taquito/utils';\r\n * const chainId = 'NetXdQprcVkpaWU'\r\n * const validation = validateChain(chainId)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateChain(value) {\n  return validatePrefixedValue(value, [Prefix.NET]);\n}\n/**\r\n * @description Used to check if a contract address is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateContractAddress } from '@taquito/utils';\r\n * const contractAddress = 'KT1JVErLYTgtY8uGGZ4mso2npTSxqVLDRVbC'\r\n * const validation = validateContractAddress(contractAddress)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateContractAddress(value) {\n  return validatePrefixedValue(value, contractPrefix);\n}\n/**\r\n * @description Used to check if a key hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateKeyHash } from '@taquito/utils';\r\n * const keyHashWithoutPrefix = '1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\r\n * const validation = validateKeyHash(keyHashWithoutPrefix)\r\n * console.log(validation)\r\n * // This example return 0 which correspond to NO_PREFIX_MATCHED\r\n * ```\r\n */\n\n\nfunction validateKeyHash(value) {\n  return validatePrefixedValue(value, implicitPrefix);\n}\n/**\r\n * @description Used to check if a signature is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateSignature } from '@taquito/utils';\r\n * const signature = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\r\n * const validation = validateSignature(signature)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateSignature(value) {\n  return validatePrefixedValue(value, signaturePrefix);\n}\n/**\r\n * @description Used to check if a public key is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validatePublicKey } from '@taquito/utils';\r\n * const publicKey = 'edpkvS5QFv7KRGfa3b87gg9DBpxSm3NpSwnjhUjNBQrRUUR66F7C9g'\r\n * const validation = validatePublicKey(publicKey)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validatePublicKey(value) {\n  return validatePrefixedValue(value, pkPrefix);\n}\n/**\r\n * @description Used to check if an operation hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateOperation } from '@taquito/utils';\r\n * const operationHash = 'oo6JPEAy8VuMRGaFuMmLNFFGdJgiaKfnmT1CpHJfKP3Ye5ZahiP'\r\n * const validation = validateOperation(operationHash)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateOperation(value) {\n  return validatePrefixedValue(value, operationPrefix);\n}\n/**\r\n * @description Used to check if a protocol hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateProtocol } from '@taquito/utils';\r\n * const protocolHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\r\n * const validation = validateProtocol(protocolHash)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateProtocol(value) {\n  return validatePrefixedValue(value, protocolPrefix);\n}\n/**\r\n * @description Used to check if a block hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateBlock } from '@taquito/utils';\r\n * const blockHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\r\n * const validation = validateBlock(blockHash)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateBlock(value) {\n  return validatePrefixedValue(value, blockPrefix);\n} // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\n\n\nconst VERSION = {\n  \"commitHash\": \"6d90b3d5e616a6e9b9ad9dd8453b5068e7396fff\",\n  \"version\": \"13.0.1\"\n};\n/**\r\n * @packageDocumentation\r\n * @module @taquito/utils\r\n */\n\n/**\r\n *\r\n * @description Hash a string using the BLAKE2b algorithm, base58 encode the hash obtained and appends the prefix 'expr' to it\r\n *\r\n * @param value Value in hex\r\n */\n\nfunction encodeExpr(value) {\n  const blakeHash = blake.blake2b(hex2buf(value), undefined, 32);\n  return b58cencode(blakeHash, prefix['expr']);\n}\n/**\r\n *\r\n * @description Return the operation hash of a signed operation\r\n * @param value Value in hex of a signed operation\r\n */\n\n\nfunction encodeOpHash(value) {\n  const blakeHash = blake.blake2b(hex2buf(value), undefined, 32);\n  return b58cencode(blakeHash, prefix.o);\n}\n/**\r\n *\r\n * @description Base58 encode a string or a Uint8Array and append a prefix to it\r\n *\r\n * @param value Value to base58 encode\r\n * @param prefix prefix to append to the encoded string\r\n */\n\n\nfunction b58cencode(value, prefix) {\n  const payloadAr = typeof value === 'string' ? Uint8Array.from(Buffer.from(value, 'hex')) : value;\n  const n = new Uint8Array(prefix.length + payloadAr.length);\n  n.set(prefix);\n  n.set(payloadAr, prefix.length);\n  return bs58check.encode(Buffer.from(n.buffer));\n}\n/**\r\n *\r\n * @description Base58 decode a string and remove the prefix from it\r\n *\r\n * @param value Value to base58 decode\r\n * @param prefix prefix to remove from the decoded string\r\n */\n\n\nconst b58cdecode = (enc, prefixArg) => bs58check.decode(enc).slice(prefixArg.length);\n/**\r\n *\r\n * @description Base58 decode a string with predefined prefix\r\n *\r\n * @param value Value to base58 decode\r\n */\n\n\nfunction b58decode(payload) {\n  const buf = bs58check.decode(payload);\n  const prefixMap = {\n    [prefix.tz1.toString()]: '0000',\n    [prefix.tz2.toString()]: '0001',\n    [prefix.tz3.toString()]: '0002'\n  };\n  const rollupPrefMap = {\n    [prefix.txr1.toString()]: '02'\n  };\n  const pref = prefixMap[new Uint8Array(buf.slice(0, 3)).toString()];\n  const rollupPref = rollupPrefMap[new Uint8Array(buf.slice(0, 4)).toString()];\n\n  if (pref) {\n    // tz addresses\n    const hex = buf2hex(buf.slice(3));\n    return pref + hex;\n  } else if (rollupPref) {\n    const hex = buf2hex(buf.slice(4));\n    return rollupPref + hex + '00';\n  } else {\n    // other (kt addresses)\n    return '01' + buf2hex(buf.slice(3, 42)) + '00';\n  }\n}\n/**\r\n *\r\n * @description b58 decode a string without predefined prefix\r\n * @param value\r\n * @returns string of bytes\r\n */\n\n\nfunction b58decodeL2Address(payload) {\n  const buf = bs58check.decode(payload); // tz4 address currently\n\n  return buf2hex(buf.slice(3, 42));\n}\n/**\r\n *\r\n * @description Base58 encode an address using predefined prefix\r\n *\r\n * @param value Address to base58 encode (tz1, tz2, tz3 or KT1)\r\n */\n\n\nfunction encodePubKey(value) {\n  if (value.substring(0, 2) === '00') {\n    const pref = {\n      '0000': prefix.tz1,\n      '0001': prefix.tz2,\n      '0002': prefix.tz3\n    };\n    return b58cencode(value.substring(4), pref[value.substring(0, 4)]);\n  } else if (value.substring(0, 2) === '02') {\n    // 42 also works but the removes the 00 padding at the end\n    return b58cencode(value.substring(2, value.length - 2), prefix.txr1);\n  }\n\n  return b58cencode(value.substring(2, 42), prefix.KT);\n}\n/**\r\n *\r\n * @description Base58 encode an address without predefined prefix\r\n * @param value Address to base58 encode (tz4) hex dec\r\n * @returns return address\r\n */\n\n\nfunction encodeL2Address(value) {\n  return b58cencode(value, prefix.tz4);\n}\n/**\r\n *\r\n * @description Base58 encode a key according to its prefix\r\n *\r\n * @param value Key to base58 encode\r\n */\n\n\nfunction encodeKey(value) {\n  if (value[0] === '0') {\n    const pref = {\n      '00': new Uint8Array([13, 15, 37, 217]),\n      '01': new Uint8Array([3, 254, 226, 86]),\n      '02': new Uint8Array([3, 178, 139, 127])\n    };\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n/**\r\n *\r\n * @description Base58 encode a key hash according to its prefix\r\n *\r\n * @param value Key hash to base58 encode\r\n */\n\n\nfunction encodeKeyHash(value) {\n  if (value[0] === '0') {\n    const pref = {\n      '00': new Uint8Array([6, 161, 159]),\n      '01': new Uint8Array([6, 161, 161]),\n      '02': new Uint8Array([6, 161, 164])\n    };\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n/**\r\n *\r\n * @description Convert an hex string to a Uint8Array\r\n *\r\n * @param hex Hex string to convert\r\n */\n\n\nconst hex2buf = hex => {\n  const match = hex.match(/[\\da-f]{2}/gi);\n\n  if (match) {\n    return new Uint8Array(match.map(h => parseInt(h, 16)));\n  } else {\n    throw new ValueConversionError(hex, 'Uint8Array');\n  }\n};\n/**\r\n *\r\n * @description Merge 2 buffers together\r\n *\r\n * @param b1 First buffer\r\n * @param b2 Second buffer\r\n */\n\n\nconst mergebuf = (b1, b2) => {\n  const r = new Uint8Array(b1.length + b2.length);\n  r.set(b1);\n  r.set(b2, b1.length);\n  return r;\n};\n/**\r\n *\r\n * @description Flatten a michelson json representation to an array\r\n *\r\n * @param s michelson json\r\n */\n\n\nconst mic2arr = function me2(s) {\n  let ret = [];\n\n  if (Object.prototype.hasOwnProperty.call(s, 'prim')) {\n    if (s.prim === 'Pair') {\n      ret.push(me2(s.args[0]));\n      ret = ret.concat(me2(s.args[1]));\n    } else if (s.prim === 'Elt') {\n      ret = {\n        key: me2(s.args[0]),\n        val: me2(s.args[1])\n      };\n    } else if (s.prim === 'True') {\n      ret = true;\n    } else if (s.prim === 'False') {\n      ret = false;\n    }\n  } else if (Array.isArray(s)) {\n    const sc = s.length;\n\n    for (let i = 0; i < sc; i++) {\n      const n = me2(s[i]);\n\n      if (typeof n.key !== 'undefined') {\n        if (Array.isArray(ret)) {\n          ret = {\n            keys: [],\n            vals: []\n          };\n        }\n\n        ret.keys.push(n.key);\n        ret.vals.push(n.val);\n      } else {\n        ret.push(n);\n      }\n    }\n  } else if (Object.prototype.hasOwnProperty.call(s, 'string')) {\n    ret = s.string;\n  } else if (Object.prototype.hasOwnProperty.call(s, 'int')) {\n    ret = parseInt(s.int, 10);\n  } else {\n    ret = s;\n  }\n\n  return ret;\n};\n/**\r\n *\r\n * @description Convert a buffer to an hex string\r\n *\r\n * @param buffer Buffer to convert\r\n */\n\n\nconst buf2hex = buffer => {\n  const byteArray = new Uint8Array(buffer);\n  const hexParts = [];\n  byteArray.forEach(byte => {\n    const hex = byte.toString(16);\n    const paddedHex = `00${hex}`.slice(-2);\n    hexParts.push(paddedHex);\n  });\n  return hexParts.join('');\n};\n/**\r\n *\r\n *  @description Gets Tezos address (PKH) from Public Key\r\n *\r\n *  @param publicKey Public Key\r\n *  @returns A string of the Tezos address (PKH) that was derived from the given Public Key\r\n */\n\n\nconst getPkhfromPk = publicKey => {\n  let encodingPrefix;\n  let prefixLen;\n  const keyPrefix = validatePkAndExtractPrefix(publicKey);\n  const decoded = b58cdecode(publicKey, prefix[keyPrefix]);\n\n  switch (keyPrefix) {\n    case Prefix.EDPK:\n      encodingPrefix = prefix[Prefix.TZ1];\n      prefixLen = prefixLength[Prefix.TZ1];\n      break;\n\n    case Prefix.SPPK:\n      encodingPrefix = prefix[Prefix.TZ2];\n      prefixLen = prefixLength[Prefix.TZ2];\n      break;\n\n    case Prefix.P2PK:\n      encodingPrefix = prefix[Prefix.TZ3];\n      prefixLen = prefixLength[Prefix.TZ3];\n      break;\n\n    case Prefix.BLPK:\n      encodingPrefix = prefix[Prefix.TZ4];\n      prefixLen = prefixLength[Prefix.TZ4];\n  }\n\n  const hashed = hash(decoded, prefixLen);\n  const result = b58cencode(hashed, encodingPrefix);\n  return result;\n};\n/**\r\n *\r\n * @description Convert a string to bytes\r\n *\r\n * @param str String to convert\r\n */\n\n\nfunction char2Bytes(str) {\n  return Buffer.from(str, 'utf8').toString('hex');\n}\n/**\r\n *\r\n * @description Convert bytes to a string\r\n *\r\n * @param str Bytes to convert\r\n */\n\n\nfunction bytes2Char(hex) {\n  return Buffer.from(hex2buf(hex)).toString('utf8');\n}\n\nexport { DeprecationError, InvalidAddressError, InvalidBlockHashError, InvalidChainIdError, InvalidContractAddressError, InvalidKeyError, InvalidKeyHashError, InvalidMessageError, InvalidOperationHashError, InvalidOperationKindError, InvalidProtocolHashError, InvalidPublicKeyError, InvalidSignatureError, Prefix, ProhibitedActionError, VERSION, ValidationResult, ValueConversionError, b58cdecode, b58cencode, b58decode, b58decodeL2Address, buf2hex, bytes2Char, char2Bytes, encodeExpr, encodeKey, encodeKeyHash, encodeL2Address, encodeOpHash, encodePubKey, getPkhfromPk, hex2buf, isValidPrefix, mergebuf, mic2arr, prefix, prefixLength, validateAddress, validateBlock, validateChain, validateContractAddress, validateKeyHash, validateOperation, validatePkAndExtractPrefix, validateProtocol, validatePublicKey, validateSignature, verifySignature };","map":{"version":3,"mappings":"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","names":["Prefix","TZ1","Uint8Array","TZ2","TZ3","TZ4","KT","KT1","EDSK","EDSK2","SPSK","P2SK","EDPK","SPPK","P2PK","BLPK","EDESK","SPESK","P2ESK","EDSIG","SPSIG","P2SIG","SIG","NET","NCE","B","O","LO","LLO","P","CO","ID","EXPR","TZ","VH","TXR1","TXI","TXM","TXC","TXMR","TXRL","TXW","InvalidKeyError","Error","constructor","errorDetail","key","name","InvalidPublicKeyError","publicKey","InvalidSignatureError","signature","InvalidMessageError","msg","InvalidContractAddressError","contractAddress","InvalidAddressError","address","InvalidChainIdError","chainId","InvalidKeyHashError","keyHash","InvalidBlockHashError","blockHash","InvalidProtocolHashError","protocolHash","InvalidOperationHashError","operationHash","InvalidOperationKindError","operationKind","DeprecationError","message","ProhibitedActionError","ValueConversionError","desiredType","value","verifySignature","messageBytes","pkPrefix","validatePkAndExtractPrefix","sigPrefix","validateSigAndExtractPrefix","decodedPublicKey","b58cdecode","prefix","decodedSig","bytesHash","hash","hex2buf","validateMessageNotEmpty","verifyEdSignature","verifySpSignature","verifyP2Signature","substring","validation","validatePublicKey","ValidationResult","VALID","INVALID_CHECKSUM","INVALID_LENGTH","NO_PREFIX_MATCHED","signaturePrefix","startsWith","substr","validateSignature","verify","e","elliptic","ec","keyFromPublic","verifySpOrP2Sig","hexSig","buf2hex","toBuffer","match","r","s","isValidPrefix","validatePrefixedValue","prefixes","RegExp","join","exec","length","prefixKey","decoded","bs58check","decodeUnsafe","slice","prefixLength","implicitPrefix","contractPrefix","operationPrefix","protocolPrefix","blockPrefix","validateAddress","validateChain","validateContractAddress","validateKeyHash","validateOperation","validateProtocol","validateBlock","encodeExpr","blakeHash","blake","blake2b","undefined","b58cencode","encodeOpHash","o","payloadAr","from","Buffer","n","set","encode","buffer","enc","prefixArg","decode","b58decode","payload","buf","prefixMap","tz1","toString","tz2","tz3","rollupPrefMap","txr1","pref","rollupPref","hex","b58decodeL2Address","encodePubKey","encodeL2Address","tz4","encodeKey","encodeKeyHash","map","h","parseInt","mergebuf","b1","b2","me2","ret","Object","prototype","hasOwnProperty","call","prim","push","args","concat","val","Array","isArray","sc","i","keys","vals","string","int","byteArray","hexParts","forEach","byte","paddedHex","encodingPrefix","prefixLen","keyPrefix","hashed","result","char2Bytes","str","bytes2Char"],"sources":["../src/constants.ts","../src/errors.ts","../src/verify-signature.ts","../src/validators.ts","../src/version.ts","../src/taquito-utils.ts"],"sourcesContent":["export enum Prefix {\n  TZ1 = 'tz1',\n  TZ2 = 'tz2',\n  TZ3 = 'tz3',\n  TZ4 = 'tz4',\n  KT = 'KT',\n  KT1 = 'KT1',\n\n  EDSK2 = 'edsk2',\n  SPSK = 'spsk',\n  P2SK = 'p2sk',\n\n  EDPK = 'edpk',\n  SPPK = 'sppk',\n  P2PK = 'p2pk',\n  BLPK = 'BLpk',\n\n  EDESK = 'edesk',\n  SPESK = 'spesk',\n  P2ESK = 'p2esk',\n\n  EDSK = 'edsk',\n  EDSIG = 'edsig',\n  SPSIG = 'spsig',\n  P2SIG = 'p2sig',\n  SIG = 'sig',\n\n  NET = 'Net',\n  NCE = 'nce',\n  B = 'B',\n  O = 'o',\n  LO = 'Lo',\n  LLO = 'LLo',\n  P = 'P',\n  CO = 'Co',\n  ID = 'id',\n\n  EXPR = 'expr',\n  TZ = 'TZ',\n\n  VH = 'vh', // block_payload_hash\n\n  //rollups\n  TXR1 = 'txr1',\n  TXI = 'txi',\n  TXM = 'txm',\n  TXC = 'txc',\n  TXMR = 'txmr',\n  TXRL = 'txM',\n  TXW = 'txw',\n\n}\n\nexport const prefix = {\n  [Prefix.TZ1]: new Uint8Array([6, 161, 159]),\n  [Prefix.TZ2]: new Uint8Array([6, 161, 161]),\n  [Prefix.TZ3]: new Uint8Array([6, 161, 164]),\n  [Prefix.TZ4]: new Uint8Array([6, 161, 166]),\n  [Prefix.KT]: new Uint8Array([2, 90, 121]),\n  [Prefix.KT1]: new Uint8Array([2, 90, 121]),\n\n  [Prefix.EDSK]: new Uint8Array([43, 246, 78, 7]),\n  [Prefix.EDSK2]: new Uint8Array([13, 15, 58, 7]),\n  [Prefix.SPSK]: new Uint8Array([17, 162, 224, 201]),\n  [Prefix.P2SK]: new Uint8Array([16, 81, 238, 189]),\n\n  [Prefix.EDPK]: new Uint8Array([13, 15, 37, 217]),\n  [Prefix.SPPK]: new Uint8Array([3, 254, 226, 86]),\n  [Prefix.P2PK]: new Uint8Array([3, 178, 139, 127]),\n  [Prefix.BLPK]: new Uint8Array([6, 149, 135, 204]),\n\n  [Prefix.EDESK]: new Uint8Array([7, 90, 60, 179, 41]),\n  [Prefix.SPESK]: new Uint8Array([0x09, 0xed, 0xf1, 0xae, 0x96]),\n  [Prefix.P2ESK]: new Uint8Array([0x09, 0x30, 0x39, 0x73, 0xab]),\n\n  [Prefix.EDSIG]: new Uint8Array([9, 245, 205, 134, 18]),\n  [Prefix.SPSIG]: new Uint8Array([13, 115, 101, 19, 63]),\n  [Prefix.P2SIG]: new Uint8Array([54, 240, 44, 52]),\n  [Prefix.SIG]: new Uint8Array([4, 130, 43]),\n\n  [Prefix.NET]: new Uint8Array([87, 82, 0]),\n  [Prefix.NCE]: new Uint8Array([69, 220, 169]),\n  [Prefix.B]: new Uint8Array([1, 52]),\n  [Prefix.O]: new Uint8Array([5, 116]),\n  [Prefix.LO]: new Uint8Array([133, 233]),\n  [Prefix.LLO]: new Uint8Array([29, 159, 109]),\n  [Prefix.P]: new Uint8Array([2, 170]),\n  [Prefix.CO]: new Uint8Array([79, 179]),\n  [Prefix.ID]: new Uint8Array([153, 103]),\n\n  [Prefix.EXPR]: new Uint8Array([13, 44, 64, 27]),\n  // Legacy prefix\n  [Prefix.TZ]: new Uint8Array([2, 90, 121]),\n\n  [Prefix.VH]: new Uint8Array([1, 106, 242]),\n\n  [Prefix.TXR1]: new Uint8Array([1, 128, 120, 31]),\n  [Prefix.TXI]: new Uint8Array([79, 148, 196]),\n  [Prefix.TXM]: new Uint8Array([79, 149, 30]),\n  [Prefix.TXC]: new Uint8Array([79, 148, 17]),\n  [Prefix.TXMR]: new Uint8Array([18, 7, 206, 87]),\n  [Prefix.TXRL]: new Uint8Array([79, 146, 82]),\n  [Prefix.TXW]: new Uint8Array([79, 150, 72]),\n\n};\n\nexport const prefixLength: { [key: string]: number } = {\n  [Prefix.TZ1]: 20,\n  [Prefix.TZ2]: 20,\n  [Prefix.TZ3]: 20,\n  [Prefix.TZ4]: 20,\n  [Prefix.KT]: 20,\n  [Prefix.KT1]: 20,\n\n  [Prefix.EDPK]: 32,\n  [Prefix.SPPK]: 33,\n  [Prefix.P2PK]: 33,\n  //working with value in comment for base58.ml line 445 but not consistent with the three above\n  [Prefix.BLPK]: 48,\n\n  [Prefix.EDSIG]: 64,\n  [Prefix.SPSIG]: 64,\n  [Prefix.P2SIG]: 64,\n  [Prefix.SIG]: 64,\n  [Prefix.NET]: 4,\n  [Prefix.B]: 32,\n  [Prefix.P]: 32,\n  [Prefix.O]: 32,\n  [Prefix.VH]: 32,\n  [Prefix.TXR1]: 20,\n  [Prefix.TXI]: 32,\n  [Prefix.TXM]: 32,\n  [Prefix.TXC]: 32,\n  [Prefix.TXMR]: 32,\n  [Prefix.TXRL]: 32,\n  [Prefix.TXW]: 32,\n\n};\n","/**\n *  @category Error\n *  @description Error that indicates an invalid key being passed or used\n */\nexport class InvalidKeyError extends Error {\n  public name = 'InvalidKeyError';\n  constructor(public key: string, public errorDetail?: string) {\n    super(`The key ${key} is invalid. ${errorDetail}`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an Invalid Public Key being passed or used\n */\nexport class InvalidPublicKeyError extends Error {\n  public name = 'InvalidPublicKeyError';\n  constructor(public publicKey: string, errorDetail?: string) {\n    super(`The public key '${publicKey}' is invalid. ${errorDetail}`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid signature being passed or used\n */\nexport class InvalidSignatureError extends Error {\n  public name = 'InvalidSignatureError';\n  constructor(public signature: string, errorDetail?: string) {\n    super(`The signature '${signature}' is invalid (${errorDetail})`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid message being passed or used\n */\nexport class InvalidMessageError extends Error {\n  public name = 'InvalidMessageError';\n  constructor(public msg: string, public errorDetail?: string) {\n    super(`The message '${msg}' is invalid. ${errorDetail}`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid contract address being passed or used\n */\nexport class InvalidContractAddressError extends Error {\n  public name = 'InvalidContractAddressError';\n  constructor(public contractAddress: string) {\n    super(`The contract address '${contractAddress}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid address being passed or used (both contract and implicit)\n */\nexport class InvalidAddressError extends Error {\n  public name = 'InvalidAddressError';\n  constructor(public address: string) {\n    super(`The address '${address}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid chain id being passed or used\n */\nexport class InvalidChainIdError extends Error {\n  public name = 'InvalidChainIdError';\n  constructor(public chainId: string) {\n    super(`The chain id '${chainId}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid key hash being passed or used\n */\nexport class InvalidKeyHashError extends Error {\n  public name = 'InvalidKeyHashError';\n  constructor(public keyHash: string) {\n    super(`The public key hash '${keyHash}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid block hash being passed or used\n */ export class InvalidBlockHashError extends Error {\n  public name = 'InvalidBlockHashError';\n  constructor(public blockHash: string) {\n    super(`The block hash '${blockHash}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates invalid protocol hash being passed or used\n */\nexport class InvalidProtocolHashError extends Error {\n  public name = 'InvalidProtocolHashError';\n  constructor(public protocolHash: string) {\n    super(`The protocol hash '${protocolHash}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid operation hash being passed or used\n */ export class InvalidOperationHashError extends Error {\n  public name = 'InvalidOperationHashError';\n  constructor(public operationHash: string) {\n    super(`The operation hash '${operationHash}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid operation kind being passed or used\n */\nexport class InvalidOperationKindError extends Error {\n  public name = 'InvalidOperationKindError';\n  constructor(public operationKind: string) {\n    super(`The operation kind '${operationKind}' is unsupported`);\n  }\n}\n\n/**\n *  @category Error\n *  @description General error that indicates something is no longer supported and/or deprecated\n */\nexport class DeprecationError extends Error {\n  public name = 'DeprecationError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n\n/**\n *  @category Error\n *  @description General error that indicates an action is prohibited or not allowed\n */\nexport class ProhibitedActionError extends Error {\n  public name = 'ProhibitedActionError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n\n/**\n *  @category Error\n *  @description General error that indicates a failure when trying to convert data from one type to another\n */\nexport class ValueConversionError extends Error {\n  public name = 'ValueConversionError';\n  constructor(public value: string, public desiredType: string) {\n    super(`Unable to convert ${value} to a ${desiredType}`);\n  }\n}\n","import { verify } from '@stablelib/ed25519';\nimport { hash } from '@stablelib/blake2b';\nimport {\n  b58cdecode,\n  buf2hex,\n  hex2buf,\n  Prefix,\n  prefix,\n  validatePublicKey,\n  validateSignature,\n  ValidationResult,\n} from './taquito-utils';\nimport elliptic from 'elliptic';\nimport toBuffer from 'typedarray-to-buffer';\nimport { InvalidMessageError, InvalidPublicKeyError, InvalidSignatureError } from './errors';\n\ntype PkPrefix = Prefix.EDPK | Prefix.SPPK | Prefix.P2PK | Prefix.BLPK;\ntype SigPrefix = Prefix.EDSIG | Prefix.SPSIG | Prefix.P2SIG | Prefix.SIG;\n\n/**\n * @description Verify signature of a payload\n *\n * @param messageBytes The forged message including the magic byte (11 for block,\n *        12 for preendorsement, 13 for endorsement, 3 for generic, 5 for the PACK format of michelson)\n * @param publicKey The public key to verify the signature against\n * @param signature The signature to verify\n * @returns A boolean indicating if the signature matches\n *\n * @example\n * ```\n * const message = '03d0c10e3ed11d7c6e3357f6ef335bab9e8f2bd54d0ce20c482e241191a6e4b8ce6c01be917311d9ac46959750e405d57e268e2ed9e174a80794fbd504e12a4a000141eb3781afed2f69679ff2bbe1c5375950b0e40d00ff000000005e05050505050507070100000024747a32526773486e74516b72794670707352466261313652546656503539684b72654a4d07070100000024747a315a6672455263414c42776d4171776f6e525859565142445439426a4e6a42484a750001';\n * const pk = 'sppk7c7hkPj47yjYFEHX85q46sFJGw6RBrqoVSHwAJAT4e14KJwzoey';\n * const sig = 'spsig1cdLkp1RLgUHAp13aRFkZ6MQDPp7xCnjAExGL3MBSdMDmT6JgQSX8cufyDgJRM3sinFtiCzLbsyP6d365EHoNevxhT47nx'\n *\n * const response = verifySignature(message, pk, sig);\n * ```\n *\n */\nexport function verifySignature(\n  messageBytes: string,\n  publicKey: string,\n  signature: string\n): boolean {\n  const pkPrefix = validatePkAndExtractPrefix(publicKey);\n  const sigPrefix = validateSigAndExtractPrefix(signature);\n\n  const decodedPublicKey = b58cdecode(publicKey, prefix[pkPrefix]);\n  const decodedSig = b58cdecode(signature, prefix[sigPrefix]);\n  const bytesHash = hash(hex2buf(validateMessageNotEmpty(messageBytes)), 32);\n\n  if (pkPrefix === Prefix.EDPK) {\n    return verifyEdSignature(decodedSig, bytesHash, decodedPublicKey);\n  } else if (pkPrefix === Prefix.SPPK) {\n    return verifySpSignature(decodedSig, bytesHash, decodedPublicKey);\n  } else if (pkPrefix === Prefix.P2PK) {\n    return verifyP2Signature(decodedSig, bytesHash, decodedPublicKey);\n  } else {\n    return false;\n  }\n}\n\nfunction validateMessageNotEmpty(message: string) {\n  if (message === '') {\n    throw new InvalidMessageError(\n      message,\n      'The message provided for verifying signature cannot be empty.'\n    );\n  }\n  return message;\n}\n\nexport function validatePkAndExtractPrefix(publicKey: string): PkPrefix {\n  if (publicKey === '') {\n    throw new InvalidPublicKeyError(publicKey, 'Public key cannot be empty');\n  }\n  const pkPrefix = publicKey.substring(0, 4);\n  const validation = validatePublicKey(publicKey);\n  if (validation !== ValidationResult.VALID) {\n    if (validation === ValidationResult.INVALID_CHECKSUM) {\n      throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid checksum');\n    } else if (validation === ValidationResult.INVALID_LENGTH) {\n      throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid length');\n    } else if (validation === ValidationResult.NO_PREFIX_MATCHED) {\n      throw new InvalidPublicKeyError(\n        publicKey,\n        `The public key provided has an unsupported prefix: ${pkPrefix}`\n      );\n    }\n  }\n  return pkPrefix as PkPrefix;\n}\n\nfunction validateSigAndExtractPrefix(signature: string): SigPrefix {\n  const signaturePrefix = signature.startsWith('sig')\n    ? signature.substr(0, 3)\n    : signature.substr(0, 5);\n  const validation = validateSignature(signature);\n  if (validation !== ValidationResult.VALID) {\n    if (validation === ValidationResult.INVALID_CHECKSUM) {\n      throw new InvalidSignatureError(signature, `invalid checksum`);\n    } else if (validation === ValidationResult.INVALID_LENGTH) {\n      throw new InvalidSignatureError(signature, 'invalid length');\n    } else if (validation === ValidationResult.NO_PREFIX_MATCHED) {\n      throw new InvalidSignatureError(signaturePrefix, 'unsupported prefix');\n    }\n  }\n  return signaturePrefix as SigPrefix;\n}\n\nfunction verifyEdSignature(\n  decodedSig: Uint8Array,\n  bytesHash: Uint8Array,\n  decodedPublicKey: Uint8Array\n) {\n  try {\n    return verify(decodedPublicKey, bytesHash, decodedSig);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction verifySpSignature(\n  decodedSig: Uint8Array,\n  bytesHash: Uint8Array,\n  decodedPublicKey: Uint8Array\n) {\n  const key = new elliptic.ec('secp256k1').keyFromPublic(decodedPublicKey);\n  return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\n\nfunction verifyP2Signature(\n  decodedSig: Uint8Array,\n  bytesHash: Uint8Array,\n  decodedPublicKey: Uint8Array\n) {\n  const key = new elliptic.ec('p256').keyFromPublic(decodedPublicKey);\n  return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\n\nfunction verifySpOrP2Sig(decodedSig: Uint8Array, bytesHash: Uint8Array, key: elliptic.ec.KeyPair) {\n  const hexSig = buf2hex(toBuffer(decodedSig));\n  const match = hexSig.match(/([a-f\\d]{64})/gi);\n  if (match) {\n    try {\n      const [r, s] = match;\n      return key.verify(bytesHash, { r, s });\n    } catch (e) {\n      return false;\n    }\n  }\n  return false;\n}\n","import { prefix, prefixLength, Prefix } from './constants';\n\nimport bs58check from 'bs58check';\n\nexport enum ValidationResult {\n  NO_PREFIX_MATCHED,\n  INVALID_CHECKSUM,\n  INVALID_LENGTH,\n  VALID,\n}\n\nexport function isValidPrefix(value: unknown): value is Prefix {\n  if (typeof value !== 'string') {\n    return false;\n  }\n\n  return value in prefix;\n}\n/**\n * @description This function is called by the validation functions ([[validateAddress]], [[validateChain]], [[validateContractAddress]], [[validateKeyHash]], [[validateSignature]], [[validatePublicKey]]).\n * Verify if the value has the right prefix or return `NO_PREFIX_MATCHED`,\n * decode the value using base58 and return `INVALID_CHECKSUM` if it fails,\n * check if the length of the value matches the prefix type or return `INVALID_LENGTH`.\n * If all checks pass, return `VALID`.\n *\n * @param value Value to validate\n * @param prefixes prefix the value should have\n */\nfunction validatePrefixedValue(value: string, prefixes: Prefix[]) {\n\n  const match = new RegExp(`^(${prefixes.join('|')})`).exec(value);\n  if (!match || match.length === 0) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  }\n\n  const prefixKey = match[0];\n\n  if (!isValidPrefix(prefixKey)) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  }\n\n  // Remove annotation from contract address before doing the validation\n  const contractAddress = /^(KT1\\w{33})(%(.*))?/.exec(value);\n  if (contractAddress) {\n    value = contractAddress[1];\n  }\n\n  // decodeUnsafe return undefined if decoding fail\n  let decoded = bs58check.decodeUnsafe(value);\n  if (!decoded) {\n    return ValidationResult.INVALID_CHECKSUM;\n  }\n\n  decoded = decoded.slice(prefix[prefixKey].length);\n  if (decoded.length !== prefixLength[prefixKey]) {\n    return ValidationResult.INVALID_LENGTH;\n  }\n\n  return ValidationResult.VALID;\n}\n\nconst implicitPrefix = [Prefix.TZ1, Prefix.TZ2, Prefix.TZ3, Prefix.TZ4];\nconst contractPrefix = [Prefix.KT1, Prefix.TXR1];\nconst signaturePrefix = [Prefix.EDSIG, Prefix.P2SIG, Prefix.SPSIG, Prefix.SIG];\nconst pkPrefix = [Prefix.EDPK, Prefix.SPPK, Prefix.P2PK, Prefix.BLPK];\nconst operationPrefix = [Prefix.O];\nconst protocolPrefix = [Prefix.P];\nconst blockPrefix = [Prefix.B]\n\n/**\n * @description Used to check if an address or a contract address is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateAddress } from '@taquito/utils';\n * const pkh = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n * const validation = validateAddress(pkh)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateAddress(value: string): ValidationResult {\n  return validatePrefixedValue(value, [...implicitPrefix, ...contractPrefix]);\n}\n\n/**\n * @description Used to check if a chain id is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateChain } from '@taquito/utils';\n * const chainId = 'NetXdQprcVkpaWU'\n * const validation = validateChain(chainId)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateChain(value: string): ValidationResult {\n  return validatePrefixedValue(value, [Prefix.NET]);\n}\n\n/**\n * @description Used to check if a contract address is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateContractAddress } from '@taquito/utils';\n * const contractAddress = 'KT1JVErLYTgtY8uGGZ4mso2npTSxqVLDRVbC'\n * const validation = validateContractAddress(contractAddress)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateContractAddress(value: string): ValidationResult {\n  return validatePrefixedValue(value, contractPrefix);\n}\n\n/**\n * @description Used to check if a key hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateKeyHash } from '@taquito/utils';\n * const keyHashWithoutPrefix = '1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n * const validation = validateKeyHash(keyHashWithoutPrefix)\n * console.log(validation)\n * // This example return 0 which correspond to NO_PREFIX_MATCHED\n * ```\n */\nexport function validateKeyHash(value: string): ValidationResult {\n  return validatePrefixedValue(value, implicitPrefix);\n}\n\n/**\n * @description Used to check if a signature is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateSignature } from '@taquito/utils';\n * const signature = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\n * const validation = validateSignature(signature)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateSignature(value: string): ValidationResult {\n  return validatePrefixedValue(value, signaturePrefix);\n}\n\n/**\n * @description Used to check if a public key is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validatePublicKey } from '@taquito/utils';\n * const publicKey = 'edpkvS5QFv7KRGfa3b87gg9DBpxSm3NpSwnjhUjNBQrRUUR66F7C9g'\n * const validation = validatePublicKey(publicKey)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validatePublicKey(value: string): ValidationResult {\n  return validatePrefixedValue(value, pkPrefix);\n}\n\n/**\n * @description Used to check if an operation hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateOperation } from '@taquito/utils';\n * const operationHash = 'oo6JPEAy8VuMRGaFuMmLNFFGdJgiaKfnmT1CpHJfKP3Ye5ZahiP'\n * const validation = validateOperation(operationHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateOperation(value: string): ValidationResult {\n  return validatePrefixedValue(value, operationPrefix);\n}\n\n/**\n * @description Used to check if a protocol hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateProtocol } from '@taquito/utils';\n * const protocolHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\n * const validation = validateProtocol(protocolHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateProtocol(value: string): ValidationResult {\n  return validatePrefixedValue(value, protocolPrefix);\n}\n\n/**\n * @description Used to check if a block hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateBlock } from '@taquito/utils';\n * const blockHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\n * const validation = validateBlock(blockHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateBlock(value: string): ValidationResult {\n  return validatePrefixedValue(value, blockPrefix);\n}\n","\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\nexport const VERSION = {\n    \"commitHash\": \"6d90b3d5e616a6e9b9ad9dd8453b5068e7396fff\",\n    \"version\": \"13.0.1\"\n};\n","/**\n * @packageDocumentation\n * @module @taquito/utils\n */\n\n/*\n * Some code in this file is originally from sotez and eztz\n * Copyright (c) 2018 Andrew Kishino\n * Copyright (c) 2017 Stephen Andrews\n */\n\nimport { Buffer } from 'buffer';\nimport { Prefix, prefix, prefixLength } from './constants';\nimport { validatePkAndExtractPrefix } from './verify-signature';\nimport { hash } from '@stablelib/blake2b';\nimport blake from 'blakejs';\nimport bs58check from 'bs58check';\nimport { ValueConversionError } from './errors';\n\nexport * from './validators';\nexport { VERSION } from './version';\n\nexport { prefix, Prefix, prefixLength } from './constants';\n\nexport { verifySignature, validatePkAndExtractPrefix } from './verify-signature';\nexport * from './errors';\n\n/**\n *\n * @description Hash a string using the BLAKE2b algorithm, base58 encode the hash obtained and appends the prefix 'expr' to it\n *\n * @param value Value in hex\n */\nexport function encodeExpr(value: string) {\n  const blakeHash = blake.blake2b(hex2buf(value), undefined, 32);\n  return b58cencode(blakeHash, prefix['expr']);\n}\n\n/**\n *\n * @description Return the operation hash of a signed operation\n * @param value Value in hex of a signed operation\n */\nexport function encodeOpHash(value: string) {\n  const blakeHash = blake.blake2b(hex2buf(value), undefined, 32);\n  return b58cencode(blakeHash, prefix.o);\n}\n\n/**\n *\n * @description Base58 encode a string or a Uint8Array and append a prefix to it\n *\n * @param value Value to base58 encode\n * @param prefix prefix to append to the encoded string\n */\nexport function b58cencode(value: string | Uint8Array, prefix: Uint8Array) {\n  const payloadAr = typeof value === 'string' ? Uint8Array.from(Buffer.from(value, 'hex')) : value;\n\n  const n = new Uint8Array(prefix.length + payloadAr.length);\n  n.set(prefix);\n  n.set(payloadAr, prefix.length);\n\n  return bs58check.encode(Buffer.from(n.buffer));\n}\n\n/**\n *\n * @description Base58 decode a string and remove the prefix from it\n *\n * @param value Value to base58 decode\n * @param prefix prefix to remove from the decoded string\n */\nexport const b58cdecode = (enc: string, prefixArg: Uint8Array): Uint8Array =>\n  bs58check.decode(enc).slice(prefixArg.length);\n\n/**\n *\n * @description Base58 decode a string with predefined prefix\n *\n * @param value Value to base58 decode\n */\nexport function b58decode(payload: string) {\n  const buf: Buffer = bs58check.decode(payload);\n\n  const prefixMap = {\n    [prefix.tz1.toString()]: '0000',\n    [prefix.tz2.toString()]: '0001',\n    [prefix.tz3.toString()]: '0002',\n  };\n\n  const rollupPrefMap = {\n    [prefix.txr1.toString()]: '02',\n  }\n\n  const pref = prefixMap[new Uint8Array(buf.slice(0, 3)).toString()];\n  const rollupPref = rollupPrefMap[new Uint8Array(buf.slice(0, 4)).toString()]\n  if (pref) {\n    // tz addresses\n    const hex = buf2hex(buf.slice(3));\n    return pref + hex;\n  } else if (rollupPref) {\n    const hex = buf2hex(buf.slice(4))\n    return rollupPref + hex + '00'\n  } else {\n    // other (kt addresses)\n    return '01' + buf2hex(buf.slice(3, 42)) + '00';\n  }\n}\n\n/**\n *\n * @description b58 decode a string without predefined prefix\n * @param value\n * @returns string of bytes\n */\nexport function b58decodeL2Address (payload: string) {\n  const buf: Buffer = bs58check.decode(payload);\n\n  // tz4 address currently\n  return buf2hex(buf.slice(3, 42))\n}\n\n/**\n *\n * @description Base58 encode an address using predefined prefix\n *\n * @param value Address to base58 encode (tz1, tz2, tz3 or KT1)\n */\nexport function encodePubKey(value: string) {\n  if (value.substring(0, 2) === '00') {\n    const pref: { [key: string]: Uint8Array } = {\n      '0000': prefix.tz1,\n      '0001': prefix.tz2,\n      '0002': prefix.tz3,\n    };\n\n    return b58cencode(value.substring(4), pref[value.substring(0, 4)]);\n  } else if (value.substring(0, 2) === '02') {\n    // 42 also works but the removes the 00 padding at the end\n    return b58cencode(value.substring(2, value.length - 2), prefix.txr1)\n  }\n  return b58cencode(value.substring(2, 42), prefix.KT);\n}\n/**\n *\n * @description Base58 encode an address without predefined prefix\n * @param value Address to base58 encode (tz4) hex dec\n * @returns return address\n */\nexport function encodeL2Address(value: string) {\n  return b58cencode(value, prefix.tz4)\n}\n/**\n *\n * @description Base58 encode a key according to its prefix\n *\n * @param value Key to base58 encode\n */\nexport function encodeKey(value: string) {\n  if (value[0] === '0') {\n    const pref: { [key: string]: Uint8Array } = {\n      '00': new Uint8Array([13, 15, 37, 217]),\n      '01': new Uint8Array([3, 254, 226, 86]),\n      '02': new Uint8Array([3, 178, 139, 127]),\n    };\n\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n\n/**\n *\n * @description Base58 encode a key hash according to its prefix\n *\n * @param value Key hash to base58 encode\n */\nexport function encodeKeyHash(value: string) {\n  if (value[0] === '0') {\n    const pref: { [key: string]: Uint8Array } = {\n      '00': new Uint8Array([6, 161, 159]),\n      '01': new Uint8Array([6, 161, 161]),\n      '02': new Uint8Array([6, 161, 164]),\n    };\n\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n\n/**\n *\n * @description Convert an hex string to a Uint8Array\n *\n * @param hex Hex string to convert\n */\nexport const hex2buf = (hex: string): Uint8Array => {\n  const match = hex.match(/[\\da-f]{2}/gi);\n  if (match) {\n    return new Uint8Array(match.map((h) => parseInt(h, 16)));\n  } else {\n    throw new ValueConversionError(hex, 'Uint8Array');\n  }\n};\n\n/**\n *\n * @description Merge 2 buffers together\n *\n * @param b1 First buffer\n * @param b2 Second buffer\n */\nexport const mergebuf = (b1: Uint8Array, b2: Uint8Array): Uint8Array => {\n  const r = new Uint8Array(b1.length + b2.length);\n  r.set(b1);\n  r.set(b2, b1.length);\n  return r;\n};\n\n/**\n *\n * @description Flatten a michelson json representation to an array\n *\n * @param s michelson json\n */\n\nexport const mic2arr = function me2(s: any): any {\n  let ret: any = [];\n  if (Object.prototype.hasOwnProperty.call(s, 'prim')) {\n    if (s.prim === 'Pair') {\n      ret.push(me2(s.args[0]));\n      ret = ret.concat(me2(s.args[1]));\n    } else if (s.prim === 'Elt') {\n      ret = {\n        key: me2(s.args[0]),\n        val: me2(s.args[1]),\n      };\n    } else if (s.prim === 'True') {\n      ret = true;\n    } else if (s.prim === 'False') {\n      ret = false;\n    }\n  } else if (Array.isArray(s)) {\n    const sc = s.length;\n    for (let i = 0; i < sc; i++) {\n      const n = me2(s[i]);\n      if (typeof n.key !== 'undefined') {\n        if (Array.isArray(ret)) {\n          ret = {\n            keys: [],\n            vals: [],\n          };\n        }\n        ret.keys.push(n.key);\n        ret.vals.push(n.val);\n      } else {\n        ret.push(n);\n      }\n    }\n  } else if (Object.prototype.hasOwnProperty.call(s, 'string')) {\n    ret = s.string;\n  } else if (Object.prototype.hasOwnProperty.call(s, 'int')) {\n    ret = parseInt(s.int, 10);\n  } else {\n    ret = s;\n  }\n  return ret;\n};\n\n/**\n *\n * @description Convert a buffer to an hex string\n *\n * @param buffer Buffer to convert\n */\nexport const buf2hex = (buffer: Buffer): string => {\n  const byteArray = new Uint8Array(buffer);\n  const hexParts: string[] = [];\n  byteArray.forEach((byte) => {\n    const hex = byte.toString(16);\n    const paddedHex = `00${hex}`.slice(-2);\n    hexParts.push(paddedHex);\n  });\n  return hexParts.join('');\n};\n\n/**\n *\n *  @description Gets Tezos address (PKH) from Public Key\n *\n *  @param publicKey Public Key\n *  @returns A string of the Tezos address (PKH) that was derived from the given Public Key\n */\nexport const getPkhfromPk = (publicKey: string): string => {\n  let encodingPrefix;\n  let prefixLen;\n\n  const keyPrefix = validatePkAndExtractPrefix(publicKey);\n  const decoded = b58cdecode(publicKey, prefix[keyPrefix]);\n\n  switch (keyPrefix) {\n    case Prefix.EDPK:\n      encodingPrefix = prefix[Prefix.TZ1];\n      prefixLen = prefixLength[Prefix.TZ1];\n      break;\n    case Prefix.SPPK:\n      encodingPrefix = prefix[Prefix.TZ2];\n      prefixLen = prefixLength[Prefix.TZ2];\n      break;\n    case Prefix.P2PK:\n      encodingPrefix = prefix[Prefix.TZ3];\n      prefixLen = prefixLength[Prefix.TZ3];\n      break;\n    case Prefix.BLPK:\n      encodingPrefix = prefix[Prefix.TZ4];\n      prefixLen = prefixLength[Prefix.TZ4]\n  }\n\n  const hashed = hash(decoded, prefixLen);\n  const result = b58cencode(hashed, encodingPrefix);\n\n  return result;\n};\n\n/**\n *\n * @description Convert a string to bytes\n *\n * @param str String to convert\n */\nexport function char2Bytes(str: string) {\n  return Buffer.from(str, 'utf8').toString('hex');\n}\n\n/**\n *\n * @description Convert bytes to a string\n *\n * @param str Bytes to convert\n */\nexport function bytes2Char(hex: string): string {\n  return Buffer.from(hex2buf(hex)).toString('utf8');\n}\n"]},"metadata":{},"sourceType":"module"}