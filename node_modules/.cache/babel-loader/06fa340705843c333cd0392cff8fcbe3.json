{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Logger } from '@airgap/beacon-core';\nimport { ExposedPromise } from '@airgap/beacon-utils';\nimport { MatrixClientStore } from './MatrixClientStore';\nimport { MatrixHttpClient } from './MatrixHttpClient';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nimport { MatrixRoomService } from './services/MatrixRoomService';\nimport { MatrixUserService } from './services/MatrixUserService';\nimport { MatrixEventService } from './services/MatrixEventService';\nimport { MatrixClientEventEmitter } from './MatrixClientEventEmitter';\nconst logger = new Logger('MatrixClient');\nconst IMMEDIATE_POLLING_RETRIES = 3;\nconst RETRY_INTERVAL = 5000;\n/**\n * The matrix client used to connect to the matrix network\n */\n\nexport class MatrixClient {\n  constructor(store, eventEmitter, userService, roomService, eventService, httpClient) {\n    this.store = store;\n    this.eventEmitter = eventEmitter;\n    this.userService = userService;\n    this.roomService = roomService;\n    this.eventService = eventService;\n    this.httpClient = httpClient;\n    this.isActive = true;\n    this._isReady = new ExposedPromise();\n    this.store.onStateChanged((oldState, newState, stateChange) => {\n      this.eventEmitter.onStateChanged(oldState, newState, stateChange);\n    }, 'rooms');\n  }\n  /**\n   * Create a matrix client based on the options provided\n   *\n   * @param config\n   */\n\n\n  static create(config) {\n    const store = new MatrixClientStore(config.storage);\n    const eventEmitter = new MatrixClientEventEmitter();\n    const httpClient = new MatrixHttpClient(config.baseUrl);\n    const accountService = new MatrixUserService(httpClient);\n    const roomService = new MatrixRoomService(httpClient);\n    const eventService = new MatrixEventService(httpClient);\n    return new MatrixClient(store, eventEmitter, accountService, roomService, eventService, httpClient);\n  }\n  /**\n   * Return all the rooms we are currently part of\n   */\n\n\n  get joinedRooms() {\n    return new Promise(resolve => __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      resolve(Object.values(this.store.get('rooms')).filter(room => room.status === MatrixRoomStatus.JOINED));\n    }));\n  }\n  /**\n   * Return all the rooms to which we have received invitations\n   */\n\n\n  get invitedRooms() {\n    return new Promise(resolve => __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      resolve(Object.values(this.store.get('rooms')).filter(room => room.status === MatrixRoomStatus.INVITED));\n    }));\n  }\n  /**\n   * Return all the rooms that we left\n   */\n\n\n  get leftRooms() {\n    return new Promise(resolve => __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      resolve(Object.values(this.store.get('rooms')).filter(room => room.status === MatrixRoomStatus.LEFT));\n    }));\n  }\n  /**\n   * Initiate the connection to the matrix node and log in\n   *\n   * @param user\n   */\n\n\n  start(user) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const response = yield this.userService.login(user.id, user.password, user.deviceId);\n      yield this.store.update({\n        accessToken: response.access_token\n      });\n      const initialPollingResult = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        yield this.poll(0, pollingResponse => __awaiter(this, void 0, void 0, function* () {\n          if (!this.store.get('isRunning')) {\n            resolve();\n          }\n\n          yield this.store.update({\n            isRunning: true,\n            syncToken: pollingResponse.next_batch,\n            pollingTimeout: 30000,\n            pollingRetries: 0,\n            rooms: MatrixRoom.fromSync(pollingResponse.rooms)\n          });\n        }), error => __awaiter(this, void 0, void 0, function* () {\n          if (!this.store.get('isRunning')) {\n            reject(error);\n          }\n\n          yield this.store.update({\n            isRunning: false,\n            pollingRetries: this.store.get('pollingRetries') + 1\n          });\n        }));\n      }));\n      initialPollingResult.then(() => {\n        this._isReady.resolve();\n      }).catch(console.error);\n      return initialPollingResult;\n    });\n  }\n\n  isConnected() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this._isReady.promise;\n    });\n  }\n  /**\n   * Stop all running requests\n   */\n\n\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log(`MATRIX CLIENT STOPPED`);\n      this.isActive = false;\n      this._isReady = new ExposedPromise();\n      return this.httpClient.cancelAllRequests();\n    });\n  }\n  /**\n   * Subscribe to new matrix events\n   *\n   * @param event\n   * @param listener\n   */\n\n\n  subscribe(event, listener) {\n    this.eventEmitter.on(event, listener);\n  }\n  /**\n   * Unsubscribe from matrix events\n   *\n   * @param event\n   * @param listener\n   */\n\n\n  unsubscribe(event, listener) {\n    if (listener) {\n      this.eventEmitter.removeListener(event, listener);\n    }\n  }\n  /**\n   * Unsubscribe from all matrix events of this type\n   *\n   * @param event\n   * @param listener\n   */\n\n\n  unsubscribeAll(event) {\n    this.eventEmitter.removeListener(event);\n  }\n\n  getRoomById(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      return this.store.getRoom(id);\n    });\n  }\n  /**\n   * Create a private room with the supplied members\n   *\n   * @param members Members that will be in the room\n   */\n\n\n  createTrustedPrivateRoom() {\n    for (var _len = arguments.length, members = new Array(_len), _key = 0; _key < _len; _key++) {\n      members[_key] = arguments[_key];\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      return this.requiresAuthorization('createRoom', accessToken => __awaiter(this, void 0, void 0, function* () {\n        const response = yield this.roomService.createRoom(accessToken, {\n          room_version: '5',\n          invite: members,\n          preset: 'public_chat',\n          is_direct: true\n        });\n        return response.room_id;\n      }));\n    });\n  }\n  /**\n   * Invite user to rooms\n   *\n   * @param user The user to be invited\n   * @param roomsOrIds The rooms the user will be invited to\n   */\n\n\n  inviteToRooms(user) {\n    for (var _len2 = arguments.length, roomsOrIds = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      roomsOrIds[_key2 - 1] = arguments[_key2];\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      yield this.requiresAuthorization('invite', accessToken => Promise.all(roomsOrIds.map(roomOrId => {\n        const room = this.store.getRoom(roomOrId);\n        this.roomService.inviteToRoom(accessToken, user, room).catch(error => logger.warn('inviteToRooms', error));\n      })));\n    });\n  }\n  /**\n   * Join rooms\n   *\n   * @param roomsOrIds\n   */\n\n\n  joinRooms() {\n    for (var _len3 = arguments.length, roomsOrIds = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      roomsOrIds[_key3] = arguments[_key3];\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      yield this.requiresAuthorization('join', accessToken => Promise.all(roomsOrIds.map(roomOrId => {\n        const room = this.store.getRoom(roomOrId);\n        return this.roomService.joinRoom(accessToken, room);\n      })));\n    });\n  }\n  /**\n   * Send a text message\n   *\n   * @param roomOrId\n   * @param message\n   */\n\n\n  sendTextMessage(roomId, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      yield this.requiresAuthorization('send', accessToken => __awaiter(this, void 0, void 0, function* () {\n        const txnId = yield this.createTxnId();\n        return this.eventService.sendMessage(accessToken, roomId, {\n          msgtype: 'm.text',\n          body: message\n        }, txnId);\n      }));\n    });\n  }\n  /**\n   * Poll the server to get the latest data and get notified of changes\n   *\n   * @param interval\n   * @param onSyncSuccess\n   * @param onSyncError\n   */\n\n\n  poll(interval, onSyncSuccess, onSyncError) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const store = this.store;\n      const sync = this.sync.bind(this);\n\n      const pollSync = (resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        let syncingRetries = 0;\n\n        try {\n          const response = yield sync();\n          onSyncSuccess(response);\n        } catch (error) {\n          onSyncError(error);\n          syncingRetries = store.get('pollingRetries'); // console.warn('Could not sync:', error)\n\n          if (this.isActive) {\n            logger.log(`Retry syncing... ${syncingRetries} retries so far`);\n          }\n        } finally {\n          if (this.isActive) {\n            setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n              yield pollSync(resolve, reject);\n            }), syncingRetries > IMMEDIATE_POLLING_RETRIES ? RETRY_INTERVAL + interval : interval);\n          } else {\n            reject(new Error(`Syncing stopped manually.`));\n          }\n        }\n      });\n\n      return new Promise(pollSync);\n    });\n  }\n  /**\n   * Get state from server\n   */\n\n\n  sync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.requiresAuthorization('sync', accessToken => __awaiter(this, void 0, void 0, function* () {\n        return this.eventService.sync(accessToken, {\n          pollingTimeout: this.store.get('pollingTimeout'),\n          syncToken: this.store.get('syncToken')\n        });\n      }));\n    });\n  }\n  /**\n   * A helper method that makes sure an access token is provided\n   *\n   * @param name\n   * @param action\n   */\n\n\n  requiresAuthorization(name, action) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const storedToken = this.store.get('accessToken');\n\n      if (!storedToken) {\n        return Promise.reject(`${name} requires authorization but no access token has been provided.`);\n      }\n\n      return action(storedToken);\n    });\n  }\n  /**\n   * Create a transaction ID\n   */\n\n\n  createTxnId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const timestamp = new Date().getTime();\n      const counter = this.store.get('txnNo');\n      yield this.store.update({\n        txnNo: counter + 1\n      });\n      return `m${timestamp}.${counter}`;\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Logger","ExposedPromise","MatrixClientStore","MatrixHttpClient","MatrixRoom","MatrixRoomStatus","MatrixRoomService","MatrixUserService","MatrixEventService","MatrixClientEventEmitter","logger","IMMEDIATE_POLLING_RETRIES","RETRY_INTERVAL","MatrixClient","constructor","store","eventEmitter","userService","roomService","eventService","httpClient","onStateChanged","oldState","newState","stateChange","create","config","storage","baseUrl","accountService","joinedRooms","Promise","resolve","__awaiter","isConnected","Object","values","get","filter","room","status","JOINED","invitedRooms","INVITED","leftRooms","LEFT","start","user","response","login","id","password","deviceId","update","accessToken","access_token","initialPollingResult","reject","poll","pollingResponse","isRunning","syncToken","next_batch","pollingTimeout","pollingRetries","rooms","fromSync","error","then","_isReady","catch","console","promise","stop","log","isActive","cancelAllRequests","subscribe","event","listener","on","unsubscribe","removeListener","unsubscribeAll","getRoomById","getRoom","createTrustedPrivateRoom","members","requiresAuthorization","createRoom","room_version","invite","preset","is_direct","room_id","inviteToRooms","roomsOrIds","all","map","roomOrId","inviteToRoom","warn","joinRooms","joinRoom","sendTextMessage","roomId","message","txnId","createTxnId","sendMessage","msgtype","body","interval","onSyncSuccess","onSyncError","sync","bind","pollSync","syncingRetries","setTimeout","Error","name","action","storedToken","timestamp","Date","getTime","counter","txnNo"],"sourceRoot":"","sources":["../../../src/matrix-client/MatrixClient.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}