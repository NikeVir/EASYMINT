{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ready, crypto_generichash, from_string, crypto_sign_detached, crypto_secretbox_NONCEBYTES, crypto_secretbox_MACBYTES } from 'libsodium-wrappers';\nimport axios from 'axios';\nimport { getHexHash, toHex, recipientString, openCryptobox, encryptCryptoboxPayload, decryptCryptoboxPayload } from '@airgap/beacon-utils';\nimport { MatrixClient } from '../matrix-client/MatrixClient';\nimport { MatrixClientEventType } from '../matrix-client/models/MatrixClientEvent';\nimport { MatrixMessageType } from '../matrix-client/models/MatrixMessage';\nimport { StorageKey } from '@airgap/beacon-types';\nimport { PeerManager, BEACON_VERSION, getSenderId, Logger, CommunicationClient } from '@airgap/beacon-core';\nimport { ExposedPromise, generateGUID } from '@airgap/beacon-utils';\nconst logger = new Logger('P2PCommunicationClient');\nexport const KNOWN_RELAY_SERVERS = ['beacon-node-1.diamond.papers.tech', 'beacon-node-1.sky.papers.tech', 'beacon-node-2.sky.papers.tech', 'beacon-node-1.hope.papers.tech', 'beacon-node-1.hope-2.papers.tech', 'beacon-node-1.hope-3.papers.tech', 'beacon-node-1.hope-4.papers.tech', 'beacon-node-1.hope-5.papers.tech'];\n/**\n * @internalapi\n */\n\nexport class P2PCommunicationClient extends CommunicationClient {\n  constructor(name, keyPair, replicationCount, storage, matrixNodes, iconUrl, appUrl) {\n    super(keyPair);\n    this.name = name;\n    this.replicationCount = replicationCount;\n    this.storage = storage;\n    this.iconUrl = iconUrl;\n    this.appUrl = appUrl;\n    this.client = new ExposedPromise();\n    this.activeListeners = new Map();\n    this.ignoredRooms = [];\n    this.loginCounter = 0;\n    logger.log('constructor', 'P2PCommunicationClient created');\n    const nodes = matrixNodes.length > 0 ? matrixNodes : KNOWN_RELAY_SERVERS;\n    this.ENABLED_RELAY_SERVERS = nodes;\n  }\n\n  getPairingRequestInfo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const info = {\n        id: yield generateGUID(),\n        type: 'p2p-pairing-request',\n        name: this.name,\n        version: BEACON_VERSION,\n        publicKey: yield this.getPublicKey(),\n        relayServer: yield this.getRelayServer()\n      };\n\n      if (this.iconUrl) {\n        info.icon = this.iconUrl;\n      }\n\n      if (this.appUrl) {\n        info.appUrl = this.appUrl;\n      }\n\n      return info;\n    });\n  }\n\n  getPairingResponseInfo(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const info = {\n        id: request.id,\n        type: 'p2p-pairing-response',\n        name: this.name,\n        version: request.version,\n        publicKey: yield this.getPublicKey(),\n        relayServer: yield this.getRelayServer()\n      };\n\n      if (this.iconUrl) {\n        info.icon = this.iconUrl;\n      }\n\n      if (this.appUrl) {\n        info.appUrl = this.appUrl;\n      }\n\n      return info;\n    });\n  }\n\n  getRelayServer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.relayServer) {\n        return this.relayServer.promise;\n      } else {\n        this.relayServer = new ExposedPromise();\n      }\n\n      const node = yield this.storage.get(StorageKey.MATRIX_SELECTED_NODE);\n\n      if (node && node.length > 0) {\n        this.relayServer.resolve(node);\n        return node;\n      }\n\n      const nodes = [...this.ENABLED_RELAY_SERVERS];\n\n      while (nodes.length > 0) {\n        const index = Math.floor(Math.random() * nodes.length);\n        const server = nodes[index];\n\n        try {\n          yield axios.get(`https://${server}/_matrix/client/versions`);\n          this.storage.set(StorageKey.MATRIX_SELECTED_NODE, server).catch(error => logger.log(error));\n          this.relayServer.resolve(server);\n          return server;\n        } catch (relayError) {\n          logger.log(`Ignoring server \"${server}\", trying another one...`);\n          nodes.splice(index, 1);\n        }\n      }\n\n      this.relayServer.reject(`No matrix server reachable!`);\n      throw new Error(`No matrix server reachable!`);\n    });\n  }\n\n  tryJoinRooms(roomId) {\n    let retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield (yield this.client.promise).joinRooms(roomId);\n      } catch (error) {\n        if (retry <= 10 && error.errcode === 'M_FORBIDDEN') {\n          // If we join the room too fast after receiving the invite, the server can accidentally reject our join. This seems to be a problem only when using a federated multi-node setup. Usually waiting for a couple milliseconds solves the issue, but to handle lag, we will keep retrying for 2 seconds.\n          logger.log(`Retrying to join...`, error);\n          setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n            yield this.tryJoinRooms(roomId, retry + 1);\n          }), 200);\n        } else {\n          logger.log(`Failed to join after ${retry} tries.`, error);\n        }\n      }\n    });\n  }\n\n  start() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('start', 'starting client');\n      yield ready;\n      logger.log('start', `connecting to server`);\n      const relayServer = yield this.getRelayServer();\n      const client = MatrixClient.create({\n        baseUrl: `https://${relayServer}`,\n        storage: this.storage\n      });\n\n      this.initialListener = event => __awaiter(this, void 0, void 0, function* () {\n        if (this.initialEvent && this.initialEvent.timestamp && event && event.timestamp) {\n          if (this.initialEvent.timestamp < event.timestamp) {\n            this.initialEvent = event;\n          }\n        } else {\n          this.initialEvent = event;\n        }\n      });\n\n      client.subscribe(MatrixClientEventType.MESSAGE, this.initialListener);\n      client.subscribe(MatrixClientEventType.INVITE, event => __awaiter(this, void 0, void 0, function* () {\n        let member;\n\n        if (event.content.members.length === 1) {\n          // If there is only one member we know it's a new room\n          // TODO: Use the \"sender\" of the event instead\n          member = event.content.members[0];\n        }\n\n        yield this.tryJoinRooms(event.content.roomId);\n\n        if (member) {\n          yield this.updateRelayServer(member);\n          yield this.updatePeerRoom(member, event.content.roomId);\n        }\n      }));\n      const loginString = `login:${Math.floor(Date.now() / 1000 / (5 * 60))}`;\n      logger.log('start', `login ${loginString}, ${yield this.getPublicKeyHash()} on ${relayServer}`);\n      const loginRawDigest = crypto_generichash(32, from_string(loginString));\n      const rawSignature = crypto_sign_detached(loginRawDigest, this.keyPair.privateKey);\n\n      try {\n        yield client.start({\n          id: yield this.getPublicKeyHash(),\n          password: `ed:${toHex(rawSignature)}:${yield this.getPublicKey()}`,\n          deviceId: toHex(this.keyPair.publicKey)\n        });\n      } catch (error) {\n        logger.error('start', 'Could not log in, retrying');\n        yield this.reset(); // If we can't log in, let's reset\n\n        if (this.loginCounter <= this.ENABLED_RELAY_SERVERS.length) {\n          this.loginCounter++;\n          this.start();\n          return;\n        } else {\n          logger.error('start', 'Tried to log in to every known beacon node, but no login was successful.');\n          throw new Error('Could not connect to any beacon nodes. Try again later.');\n        }\n      }\n\n      logger.log('start', 'login successful, client is ready');\n      this.client.resolve(client);\n    });\n  }\n\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('stop', 'stopping client');\n\n      if (this.client.isResolved()) {\n        yield (yield this.client.promise).stop().catch(error => logger.error(error));\n      }\n\n      yield this.reset();\n    });\n  }\n\n  reset() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('reset', 'resetting connection');\n      yield this.storage.delete(StorageKey.MATRIX_PEER_ROOM_IDS).catch(error => logger.log(error));\n      yield this.storage.delete(StorageKey.MATRIX_PRESERVED_STATE).catch(error => logger.log(error));\n      yield this.storage.delete(StorageKey.MATRIX_SELECTED_NODE).catch(error => logger.log(error)); // Instead of resetting everything, maybe we should make sure a new instance is created?\n\n      this.relayServer = undefined;\n      this.client = new ExposedPromise();\n      this.initialEvent = undefined;\n      this.initialListener = undefined;\n    });\n  }\n\n  listenForEncryptedMessage(senderPublicKey, messageCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.activeListeners.has(senderPublicKey)) {\n        return;\n      }\n\n      logger.log('listenForEncryptedMessage', `start listening for encrypted messages from publicKey ${senderPublicKey}`);\n      const {\n        sharedRx\n      } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n\n      const callbackFunction = event => __awaiter(this, void 0, void 0, function* () {\n        if (this.isTextMessage(event.content) && (yield this.isSender(event, senderPublicKey))) {\n          let payload;\n          yield this.updateRelayServer(event.content.message.sender);\n          yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n\n          try {\n            payload = Buffer.from(event.content.message.content, 'hex'); // content can be non-hex if it's a connection open request\n          } catch (_a) {\n            /* */\n          }\n\n          if (payload && payload.length >= crypto_secretbox_NONCEBYTES + crypto_secretbox_MACBYTES) {\n            try {\n              const decryptedMessage = yield decryptCryptoboxPayload(payload, sharedRx);\n              logger.log('listenForEncryptedMessage', `received a message from ${senderPublicKey}`, decryptedMessage); // logger.log(\n              //   'listenForEncryptedMessage',\n              //   'encrypted message received',\n              //   decryptedMessage,\n              //   await new Serializer().deserialize(decryptedMessage)\n              // )\n              // console.log('calculated sender ID', await getSenderId(senderPublicKey))\n              // TODO: Add check for correct decryption key / sender ID\n\n              messageCallback(decryptedMessage);\n            } catch (decryptionError) {\n              /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n            }\n          }\n        }\n      });\n\n      this.activeListeners.set(senderPublicKey, callbackFunction);\n      (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, callbackFunction);\n      const lastEvent = this.initialEvent;\n\n      if (lastEvent && lastEvent.timestamp && new Date().getTime() - lastEvent.timestamp < 5 * 60 * 1000) {\n        logger.log('listenForEncryptedMessage', 'Handling previous event');\n        yield callbackFunction(lastEvent);\n      } else {\n        logger.log('listenForEncryptedMessage', 'No previous event found');\n      }\n\n      const initialListener = this.initialListener;\n\n      if (initialListener) {\n        ;\n        (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, initialListener);\n      }\n\n      this.initialListener = undefined;\n      this.initialEvent = undefined;\n    });\n  }\n\n  unsubscribeFromEncryptedMessage(senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const listener = this.activeListeners.get(senderPublicKey);\n\n      if (!listener) {\n        return;\n      }\n\n      ;\n      (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, listener);\n      this.activeListeners.delete(senderPublicKey);\n    });\n  }\n\n  unsubscribeFromEncryptedMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      ;\n      (yield this.client.promise).unsubscribeAll(MatrixClientEventType.MESSAGE);\n      this.activeListeners.clear();\n    });\n  }\n\n  sendMessage(message, peer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        sharedTx\n      } = yield this.createCryptoBoxClient(peer.publicKey, this.keyPair.privateKey);\n      const recipientHash = yield getHexHash(Buffer.from(peer.publicKey, 'hex'));\n      const recipient = recipientString(recipientHash, peer.relayServer);\n      const roomId = yield this.getRelevantRoom(recipient); // Before we send the message, we have to wait for the join to be accepted.\n\n      yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n\n      const encryptedMessage = yield encryptCryptoboxPayload(message, sharedTx);\n      logger.log('sendMessage', 'sending encrypted message', peer.publicKey, roomId, message);\n      (yield this.client.promise).sendTextMessage(roomId, encryptedMessage).catch(error => __awaiter(this, void 0, void 0, function* () {\n        if (error.errcode === 'M_FORBIDDEN') {\n          // Room doesn't exist\n          logger.log(`sendMessage`, `M_FORBIDDEN`, roomId, error);\n          yield this.deleteRoomIdFromRooms(roomId);\n          const newRoomId = yield this.getRelevantRoom(recipient);\n          logger.log(`sendMessage`, `Old room deleted, new room created`, newRoomId);\n          (yield this.client.promise).sendTextMessage(newRoomId, encryptedMessage).catch(error2 => __awaiter(this, void 0, void 0, function* () {\n            logger.log(`sendMessage`, `inner error`, newRoomId, error2);\n          }));\n        } else {\n          logger.log(`sendMessage`, `unexpected error`, error);\n        }\n      }));\n    });\n  }\n\n  updatePeerRoom(sender, roomId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log(`updatePeerRoom`, sender, roomId); // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n\n      const split = sender.split(':');\n\n      if (split.length < 2 || !split[0].startsWith('@')) {\n        throw new Error('Invalid sender');\n      }\n\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      const room = roomIds[sender];\n\n      if (room === roomId) {\n        logger.debug(`updatePeerRoom`, `rooms are the same, not updating`);\n      }\n\n      logger.debug(`updatePeerRoom`, `current room`, room, 'new room', roomId);\n\n      if (room && room[1]) {\n        // If we have a room already, let's ignore it. We need to do this, otherwise it will be loaded from the matrix cache.\n        logger.log(`updatePeerRoom`, `adding room \"${room[1]}\" to ignored array`);\n        this.ignoredRooms.push(room[1]);\n      }\n\n      roomIds[sender] = roomId;\n      yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds); // TODO: We also need to delete the room from the sync state\n      // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n    });\n  }\n\n  deleteRoomIdFromRooms(roomId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      const newRoomIds = Object.entries(roomIds).filter(entry => entry[1] !== roomId).reduce((pv, cv) => Object.assign(Object.assign({}, pv), {\n        [cv[0]]: cv[1]\n      }), {});\n      yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, newRoomIds); // TODO: We also need to delete the room from the sync state\n      // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n\n      this.ignoredRooms.push(roomId);\n    });\n  }\n\n  listenForChannelOpening(messageCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug(`listenForChannelOpening`);\n      (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, event => __awaiter(this, void 0, void 0, function* () {\n        if (this.isTextMessage(event.content) && (yield this.isChannelOpenMessage(event.content))) {\n          logger.log(`listenForChannelOpening`, `channel opening received, trying to decrypt`, JSON.stringify(event));\n          yield this.updateRelayServer(event.content.message.sender);\n          yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n          const splits = event.content.message.content.split(':');\n          const payload = Buffer.from(splits[splits.length - 1], 'hex');\n\n          if (payload.length >= crypto_secretbox_NONCEBYTES + crypto_secretbox_MACBYTES) {\n            try {\n              const pairingResponse = JSON.parse(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.privateKey));\n              logger.log(`listenForChannelOpening`, `channel opening received and decrypted`, JSON.stringify(pairingResponse));\n              messageCallback(Object.assign(Object.assign({}, pairingResponse), {\n                senderId: yield getSenderId(pairingResponse.publicKey)\n              }));\n            } catch (decryptionError) {\n              /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n            }\n          }\n        }\n      }));\n    });\n  }\n\n  waitForJoin(roomId) {\n    let retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return __awaiter(this, void 0, void 0, function* () {\n      // Rooms are updated as new events come in. `client.getRoomById` only accesses memory, it does not do any network requests.\n      // TODO: Improve to listen to \"JOIN\" event\n      const room = yield (yield this.client.promise).getRoomById(roomId);\n      logger.log(`waitForJoin`, `Currently ${room.members.length} members, we need at least 2`);\n\n      if (room.members.length >= 2 || room.members.length === 0) {\n        // 0 means it's an unknown room, we don't need to wait\n        return;\n      } else {\n        if (retry <= 200) {\n          // On mobile, due to app switching, we potentially have to wait for a long time\n          logger.log(`Waiting for join... Try: ${retry}`);\n          return new Promise(resolve => {\n            setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n              resolve(this.waitForJoin(roomId, retry + 1));\n            }), 100 * (retry > 50 ? 10 : 1)); // After the initial 5 seconds, retry only once per second\n          });\n        } else {\n          throw new Error(`No one joined after ${retry} tries.`);\n        }\n      }\n    });\n  }\n\n  sendPairingResponse(pairingRequest) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log(`sendPairingResponse`);\n      const recipientHash = yield getHexHash(Buffer.from(pairingRequest.publicKey, 'hex'));\n      const recipient = recipientString(recipientHash, pairingRequest.relayServer); // We force room creation here because if we \"re-pair\", we need to make sure that we don't send it to an old room.\n\n      const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n      logger.debug(`sendPairingResponse`, `Connecting to room \"${roomId}\"`);\n      yield this.updatePeerRoom(recipient, roomId); // Before we send the message, we have to wait for the join to be accepted.\n\n      yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n\n      logger.debug(`sendPairingResponse`, `Successfully joined room.`); // TODO: remove v1 backwards-compatibility\n\n      const message = typeof pairingRequest.version === 'undefined' ? yield this.getPublicKey() // v1\n      : JSON.stringify(yield this.getPairingResponseInfo(pairingRequest)); // v2\n\n      logger.debug(`sendPairingResponse`, `Sending pairing response`, message);\n      const encryptedMessage = yield this.encryptMessageAsymmetric(pairingRequest.publicKey, message);\n      const msg = ['@channel-open', recipient, encryptedMessage].join(':');\n      (yield this.client.promise).sendTextMessage(roomId, msg).catch(error => __awaiter(this, void 0, void 0, function* () {\n        if (error.errcode === 'M_FORBIDDEN') {\n          // Room doesn't exist\n          logger.log(`sendPairingResponse`, `M_FORBIDDEN`, roomId, error);\n          yield this.deleteRoomIdFromRooms(roomId);\n          const newRoomId = yield this.getRelevantRoom(recipient);\n          logger.log(`sendPairingResponse`, `Old room deleted, new room created`, newRoomId);\n          (yield this.client.promise).sendTextMessage(newRoomId, msg).catch(error2 => __awaiter(this, void 0, void 0, function* () {\n            logger.log(`sendPairingResponse`, `inner error`, newRoomId, error2);\n          }));\n        } else {\n          logger.log(`sendPairingResponse`, `unexpected error`, error);\n        }\n      }));\n    });\n  }\n\n  isTextMessage(content) {\n    return content.message.type === MatrixMessageType.TEXT;\n  }\n\n  updateRelayServer(sender) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log(`updateRelayServer`, sender); // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n\n      const split = sender.split(':');\n\n      if (split.length < 2 || !split[0].startsWith('@')) {\n        throw new Error('Invalid sender');\n      }\n\n      const senderHash = split.shift();\n      const relayServer = split.join(':');\n      const manager = localStorage.getItem('beacon:communication-peers-dapp') ? new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_DAPP) : new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_WALLET);\n      const peers = yield manager.getPeers();\n      const promiseArray = peers.map(peer => __awaiter(this, void 0, void 0, function* () {\n        const hash = `@${yield getHexHash(Buffer.from(peer.publicKey, 'hex'))}`;\n\n        if (hash === senderHash) {\n          if (peer.relayServer !== relayServer) {\n            peer.relayServer = relayServer;\n            yield manager.addPeer(peer);\n          }\n        }\n      }));\n      yield Promise.all(promiseArray);\n    });\n  }\n\n  isChannelOpenMessage(content) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return content.message.content.startsWith(`@channel-open:@${yield getHexHash(Buffer.from(yield this.getPublicKey(), 'hex'))}`);\n    });\n  }\n\n  isSender(event, senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return event.content.message.sender.startsWith(`@${yield getHexHash(Buffer.from(senderPublicKey, 'hex'))}`);\n    });\n  }\n\n  getRelevantRoom(recipient) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      let roomId = roomIds[recipient];\n\n      if (!roomId) {\n        logger.log(`getRelevantRoom`, `No room found for peer ${recipient}, checking joined ones.`);\n        const room = yield this.getRelevantJoinedRoom(recipient);\n        roomId = room.id;\n        roomIds[recipient] = room.id;\n        yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);\n      }\n\n      logger.log(`getRelevantRoom`, `Using room ${roomId}`);\n      return roomId;\n    });\n  }\n\n  getRelevantJoinedRoom(recipient) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const joinedRooms = yield (yield this.client.promise).joinedRooms;\n      logger.log('checking joined rooms', joinedRooms, recipient);\n      const relevantRooms = joinedRooms.filter(roomElement => !this.ignoredRooms.some(id => roomElement.id === id)).filter(roomElement => roomElement.members.some(member => member === recipient));\n      let room; // We always create a new room if one has been ignored. This is because if we ignore one, we know the server state changed.\n      // So we cannot trust the current sync state. This can be removed once we have a method to properly clear and refresh the sync state.\n\n      if (relevantRooms.length === 0 || this.ignoredRooms.length > 0) {\n        logger.log(`getRelevantJoinedRoom`, `no relevant rooms found, creating new one`);\n        const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n        room = yield (yield this.client.promise).getRoomById(roomId);\n        logger.log(`getRelevantJoinedRoom`, `waiting for other party to join room: ${room.id}`);\n        yield this.waitForJoin(roomId);\n        logger.log(`getRelevantJoinedRoom`, `new room created and peer invited: ${room.id}`);\n      } else {\n        room = relevantRooms[0];\n        logger.log(`getRelevantJoinedRoom`, `channel already open, reusing room ${room.id}`);\n      }\n\n      return room;\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["ready","crypto_generichash","from_string","crypto_sign_detached","crypto_secretbox_NONCEBYTES","crypto_secretbox_MACBYTES","axios","getHexHash","toHex","recipientString","openCryptobox","encryptCryptoboxPayload","decryptCryptoboxPayload","MatrixClient","MatrixClientEventType","MatrixMessageType","StorageKey","PeerManager","BEACON_VERSION","getSenderId","Logger","CommunicationClient","ExposedPromise","generateGUID","logger","KNOWN_RELAY_SERVERS","P2PCommunicationClient","constructor","name","keyPair","replicationCount","storage","matrixNodes","iconUrl","appUrl","Map","log","nodes","length","ENABLED_RELAY_SERVERS","getPairingRequestInfo","info","id","type","version","publicKey","getPublicKey","relayServer","getRelayServer","icon","getPairingResponseInfo","request","promise","node","get","MATRIX_SELECTED_NODE","resolve","index","Math","floor","random","server","set","catch","error","relayError","splice","reject","Error","tryJoinRooms","roomId","retry","client","joinRooms","errcode","setTimeout","__awaiter","start","create","baseUrl","initialListener","event","initialEvent","timestamp","subscribe","MESSAGE","INVITE","member","content","members","updateRelayServer","updatePeerRoom","loginString","Date","now","getPublicKeyHash","loginRawDigest","rawSignature","privateKey","password","deviceId","reset","loginCounter","stop","isResolved","delete","MATRIX_PEER_ROOM_IDS","MATRIX_PRESERVED_STATE","undefined","listenForEncryptedMessage","senderPublicKey","messageCallback","activeListeners","has","sharedRx","createCryptoBoxServer","callbackFunction","isTextMessage","isSender","payload","message","sender","Buffer","from","decryptedMessage","decryptionError","lastEvent","getTime","unsubscribe","unsubscribeFromEncryptedMessage","listener","unsubscribeFromEncryptedMessages","unsubscribeAll","clear","sendMessage","peer","sharedTx","createCryptoBoxClient","recipientHash","recipient","getRelevantRoom","waitForJoin","encryptedMessage","sendTextMessage","deleteRoomIdFromRooms","newRoomId","error2","split","startsWith","roomIds","room","debug","ignoredRooms","push","newRoomIds","Object","entries","filter","entry","reduce","pv","cv","listenForChannelOpening","isChannelOpenMessage","JSON","stringify","splits","pairingResponse","parse","senderId","getRoomById","Promise","sendPairingResponse","pairingRequest","createTrustedPrivateRoom","encryptMessageAsymmetric","msg","join","TEXT","senderHash","shift","manager","localStorage","getItem","TRANSPORT_P2P_PEERS_DAPP","TRANSPORT_P2P_PEERS_WALLET","peers","getPeers","promiseArray","map","hash","addPeer","all","getRelevantJoinedRoom","joinedRooms","relevantRooms","roomElement","some"],"sourceRoot":"","sources":["../../../src/communication-client/P2PCommunicationClient.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}